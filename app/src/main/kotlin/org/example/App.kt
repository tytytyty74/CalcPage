/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import javafx.application.Application
import javafx.collections.FXCollections
import javafx.collections.ObservableList
import javafx.fxml.FXML
import javafx.fxml.FXMLLoader
import javafx.scene.Parent
import javafx.scene.Scene
import javafx.scene.control.ListView
import javafx.scene.control.TextArea
import javafx.stage.Stage
import org.example.Expression.Calculation
import org.typemeta.funcj.data.Chr
import org.typemeta.funcj.parser.Combinators.choice
import org.typemeta.funcj.parser.Input
import org.typemeta.funcj.parser.Parser
import org.typemeta.funcj.parser.Ref
import org.typemeta.funcj.parser.Result
import org.typemeta.funcj.parser.Text.chr
import org.typemeta.funcj.parser.Text.ws


class App : Application() {
    val greeting: String
        get() {
            return "Hello World!"
        }


    @Throws(Exception::class)
    override fun start(primaryStage: Stage) {
        val xml = this.javaClass.getResource("/main.fxml")
        println(xml)
        val root = FXMLLoader.load<Parent>(xml)

        val scene = Scene(root, 800.0, 450.0)

//        scene.getStylesheets().add(javaClass.getResource("demo.css").toExternalForm())
        primaryStage.setScene(scene)

        primaryStage.show()
    }

    fun pubLaunch() {
        launch()
    }

    fun initialize() {
        mainList!!.items = listText
    }

    @FXML
    var mainText: TextArea? = null

    @FXML
    var mainList: ListView<String>? = null
    var listText: ObservableList<String> = FXCollections.observableArrayList<String>()
    fun onChange() {

        val t = mainText!!.text.split("\n")
        for (i in 0..t.size - 1) {
            val result = parser().parse(t[i])
            when (result) {
                is Result.Success -> {
                    if (listText.size <= i) {
                        listText.add(result.getOrThrow().evaluate().toString())
                    } else {
                        listText[i] = result.getOrThrow().evaluate().toString()
                    }
                }
                is Result.Failure -> {
                    if (listText.size <= i) {
                        listText.add(t[i])
                    } else {
                        listText[i] = t[i]
                    }
                }
            }

        }
    }
}

fun main() {
    test()
    println("hiya")
    val app = App()
    app.pubLaunch()
}

class parser {
    val level1Ops = choice(Operator.Add().parse, Operator.Sub().parse)
    val level1: Ref<Chr, Expression> = Parser.ref()

    val level2Ops = choice(Operator.Mul().parse, Operator.Div().parse)
    val level2: Ref<Chr, Expression> = Parser.ref()

    val level3: Ref<Chr, Expression> = Parser.ref()

    constructor() {
        var temp = level2.and(
            level1Ops.and(level1)
                .map { a, b -> Pair(a, b) }.optional()
        )
            .map { a, b -> if (b.isEmpty) a else Calculation(b.get().first, a, b.get().second) }
        level1.set(temp)


        temp = level3.and(
            level2Ops.and(level2)
                .map { a, b -> Pair(a, b) }.optional()
        )
            .map { a, b -> if (b.isEmpty) a else Calculation(b.get().first, a, b.get().second) }
        level2.set(temp)

        temp =
            ws.many().andR(level1.between(chr('('), addWs(chr(')'))).or(Expression.dbleExpr))
        level3.set(temp)



    }

    fun <A> addWs(p: Parser<Chr, A>): Parser<Chr, A> {
        return ws.many().andR(p).andL(ws.many())

    }
    fun parse(s:String) : Result<Chr, Expression> {
        return level1.parse(Input.of(s))
    }

}

fun test() {
    chr('+')
    chr('*')

    val level1Ops = choice(Operator.Add().parse, Operator.Sub().parse)
    val level1: Ref<Chr, Expression> = Parser.ref()

    val level2Ops = choice(Operator.Mul().parse, Operator.Div().parse)
    val level2: Ref<Chr, Expression> = Parser.ref()

    var temp = level2.and(
        level1Ops.and(level1)
            .map { a, b -> Pair(a, b) }.optional()
    )
        .map { a, b -> if (b.isEmpty) a else Calculation(b.get().first, a, b.get().second) }
    level1.set(temp)


    temp = Expression.dbleExpr.and(
        level2Ops.and(level2)
            .map { a, b -> Pair(a, b) }.optional()
    )
        .map { a, b -> if (b.isEmpty) a else Calculation(b.get().first, a, b.get().second) }
    level2.set(temp)

    val v1 = "-1/2/3/4"
    val v2 = "1-2-3-4-6"
    println("hello world")
    val temp1 = level1.parse(Input.of(v1)).getOrThrow()
    val temp2 = level1.parse(Input.of(v2)).getOrThrow()
    println(temp1.evaluate())
    println(temp1)
    println(temp2.evaluate())
    println(temp2)

}