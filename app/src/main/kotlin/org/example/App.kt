/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import javafx.application.Application
import javafx.scene.Scene
import javafx.scene.control.Label
import javafx.scene.layout.StackPane
import javafx.stage.Stage
import org.typemeta.funcj.parser.Parser
import org.typemeta.funcj.data.Chr
import org.typemeta.funcj.parser.Text.alpha
import org.typemeta.funcj.parser.Text.intr
import org.typemeta.funcj.parser.Text.ws
import org.typemeta.funcj.parser.Text.chr
import org.typemeta.funcj.parser.Input

import org.example.inner.Foo

val foo1 = Foo.Foo2()
val foo2 = Foo.Foo2()
val foo3 = Foo.Foo2()
val foo4 = Foo.Foo2()
val foo5 = Foo.Foo2()

class App : Application() {
    val greeting: String
        get() {
            return "Hello World!"
        }

    override fun start(stage: Stage) {
        val javaVersion = System.getProperty("java.version")
        val javafxVersion = System.getProperty("javafx.version")
        val l = Label("Hello, JavaFX " + javafxVersion + ", running on Java " + javaVersion + ".")
        val scene = Scene(StackPane(l), 640.0, 480.0)
        stage.setScene(scene)
        stage.show()
    }

    fun pub_launch() {
        launch()
    }
}

fun main() {
    test()
    println("hiya")
    val app = App()
    app.pub_launch()
}

sealed class Unit(name: String, base:Int) {
    val name = name
    class Length(name: String, base:Int): Unit(name, base) 
    class Time

    class Multiplied(a: Unit, b: Unit): 
    class Divided(a: Unit, b: Unit):
    class Exponent(a: Unit, exponent: Int)


    

}



val meters = Unit.Length("meter", 1) 

class Length(inMeters: Double) {
    val inMeters = inMeters
    
}

sealed class UnitOrSum(s: String) {
    val s = s
    class Unit(unit: IntWithUnit): UnitOrSum(unit.toString()) 
    class Sum(i: Int): UnitOrSum(i.toString())
    
    override fun toString(): String {
        return s
    }
} 

class IntWithUnit(num: Int, unit: String) {
    val num = num
    val unit = unit

    companion object {
        fun parser(): Parser<Chr, IntWithUnit> {
            val wsParser = ws.many()
            val unitParser = alpha.many1().map(Chr::listToString)

            return intr.andL(wsParser).and(unitParser).map({ i,u -> IntWithUnit(i,u)})
        }
    }

    override fun toString(): String {
        return num.toString() + unit
    }
}

fun test() {
    val sum: Parser<Chr, Int> = intr.andL(chr('+')).and(intr).map(Integer::sum);
    val diff: Parser<Chr, Int> = intr.andL(chr('-')).and(intr).map({a,b -> a-b});
    val neg: Parser<Chr, Int> = chr('-').andR(intr);
    val addOrSub = neg.or(sum)
    //val i = sum.parse(Input.of("1 +2")).getOrThrow();
    val unit = IntWithUnit.parser();
    //val i = unit.parse(Input.of("234  meters")).getOrThrow();

    val unitOrSum: Parser<Chr, UnitOrSum> = sum.map({i -> UnitOrSum.Sum(i)}).cast<UnitOrSum>().or(unit.map({u -> UnitOrSum.Unit(u)}).cast())

    val i1 = addOrSub.parse(Input.of("1+2")).getOrThrow()
    val i2 = addOrSub.parse(Input.of("-2")).getOrThrow()

    println(i1)
    println(i2)
}