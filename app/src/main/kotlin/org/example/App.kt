/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import javafx.application.Application
import javafx.collections.FXCollections
import javafx.collections.ObservableList
import javafx.fxml.FXML
import javafx.fxml.FXMLLoader
import javafx.scene.Parent
import javafx.scene.Scene
import javafx.scene.control.ListView
import javafx.scene.control.TextArea
import javafx.stage.Stage
import org.example.expression.Context
import org.example.expression.Expression
import org.example.expression.Expression.Calculation
import org.example.expression.Operator
import org.typemeta.funcj.data.Chr
import org.typemeta.funcj.data.IList
import org.typemeta.funcj.parser.Combinators.*
import org.typemeta.funcj.parser.Input
import org.typemeta.funcj.parser.Parser
import org.typemeta.funcj.parser.Ref
import org.typemeta.funcj.parser.Text.*
import org.typemeta.funcj.parser.Result
import org.typemeta.funcj.tuples.Tuple2
import java.util.*


class App : Application() {
    val p = mainParse()
    val greeting: String
        get() {
            return "Hello World!"
        }


    @Throws(Exception::class)
    override fun start(primaryStage: Stage) {
        val xml = this.javaClass.getResource("/main.fxml")
        println(xml)
        val root = FXMLLoader.load<Parent>(xml)

        val scene = Scene(root, 800.0, 450.0)

//        scene.getStylesheets().add(javaClass.getResource("demo.css").toExternalForm())
        primaryStage.setScene(scene)

        primaryStage.show()
    }

    fun pubLaunch() {
        launch()
    }

    fun initialize() {
        mainList!!.items = listText
    }

    @FXML
    var mainText: TextArea? = null

    @FXML
    var mainList: ListView<String>? = null
    var listText: ObservableList<String> = FXCollections.observableArrayList<String>()
    fun onChange() {
        val t = mainText!!.text.split("\n")
        var c = Context()
        for (i in 0..t.size - 1) {
            val result = p.parse(t[i], c)

            if (listText.size <= i) {
                listText.add(result)
            } else {
                listText[i] = result
            }

        }
    }
}

fun main() {
    println("hiya")
    val app = App()
    app.pubLaunch()
}

class mainParse {
    val varname = alpha.and(alphaNum.many()).map { a, b -> b.fold(a.toString()) { i, j -> i + j.toString() } }.andL(ws.many())

    val level1Ops = choice(Operator.Add().parse, Operator.Sub().parse, Operator.Assign().parse)
    val level1: Ref<Chr, Expression> = Parser.ref()

    val level2Ops = choice(Operator.Mul().parse, Operator.Div().parse)
    val level2: Ref<Chr, Expression> = Parser.ref()

    val level3: Ref<Chr, Expression> = Parser.ref()
    val varCheck = product(varname.andL(addWs(chr('='))), level1)

    constructor() {
        var temp = level2.and(
            product(level1Ops, level1).optional()
        )
            .map { a, b -> makeExpr(a, b) }
        level1.set(temp)


        temp = level3.and(
            product(level2Ops, level2).optional()
        )
            .map { a, b -> makeExpr(a, b) }
        level2.set(temp)

        temp =
            ws.many().andR(level1.between(chr('('), addWs(chr(')'))).or(Expression.dbleExpr))
        level3.set(temp)


    }

    fun makeExpr(a: Expression, b: Optional<Tuple2<Operator, Expression>>): Expression {
        return b.map { n -> Calculation(n.get1(), a, n.get2()) as Expression }.orElse(a)

    }

    fun <A> addWs(p: Parser<Chr, A>): Parser<Chr, A> {
        return ws.many().andR(p).andL(ws.many())

    }

    fun parse(s: String, c: Context): String {
        val i = Input.of(s)
        val test = level1

        val x = test.parse(i).map{a -> a.evaluate(c).map { b -> b.toString() }.orElse(s)}.orElse(s)
        return x
    }

    companion object {
        fun <I, A>choice2(opts:List<Parser<I, A>>): Parser<I, A> {
            val temp = IList.ofIterable(opts)
            return Parser.choice(temp.nonEmptyOpt().orElse(IList.of(fail<I, A>())))
        }

        fun stringChoice(opts:List<String>) : Parser<Chr, String> {
            return choice2(opts.map{a -> string(a)})
        }
    }
    fun <T, B> Result<T, B>.orElse(i: B,) : B {
        return this.match({a -> a.getOrThrow()}, {_ -> i})
    }
}
