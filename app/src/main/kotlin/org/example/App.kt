/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import javafx.application.Application
import javafx.collections.FXCollections
import javafx.collections.ObservableList
import javafx.fxml.FXML
import javafx.fxml.FXMLLoader
import javafx.scene.Parent
import javafx.scene.Scene
import javafx.scene.control.ListView
import javafx.scene.control.TextArea
import javafx.stage.Stage
import org.example.Expression.Calculation
import org.typemeta.funcj.data.Chr
import org.typemeta.funcj.data.IList
import org.typemeta.funcj.parser.Combinators.*
import org.typemeta.funcj.parser.Input
import org.typemeta.funcj.parser.Parser
import org.typemeta.funcj.parser.Ref
import org.typemeta.funcj.parser.Text.*
import org.typemeta.funcj.tuples.Tuple2
import java.util.*


class App : Application() {
    val p = mainParse()
    val greeting: String
        get() {
            return "Hello World!"
        }


    @Throws(Exception::class)
    override fun start(primaryStage: Stage) {
        val xml = this.javaClass.getResource("/main.fxml")
        println(xml)
        val root = FXMLLoader.load<Parent>(xml)

        val scene = Scene(root, 800.0, 450.0)

//        scene.getStylesheets().add(javaClass.getResource("demo.css").toExternalForm())
        primaryStage.setScene(scene)

        primaryStage.show()
    }

    fun pubLaunch() {
        launch()
    }

    fun initialize() {
        mainList!!.items = listText
    }

    @FXML
    var mainText: TextArea? = null

    @FXML
    var mainList: ListView<String>? = null
    var listText: ObservableList<String> = FXCollections.observableArrayList<String>()
    fun onChange() {
        Expression.resetVars()
        val t = mainText!!.text.split("\n")
        for (i in 0..t.size - 1) {
            val result = p.parse(t[i])

            if (listText.size <= i) {
                listText.add(result)
            } else {
                listText[i] = result
            }

        }
    }
}

fun main() {
    test()
    println("hiya")
    val app = App()
    app.pubLaunch()
}

class mainParse {
    val varname = alpha.and(alphaNum.many()).map { a, b -> b.fold(a.toString()) { i, j -> i + j.toString() } }

    val level1Ops = choice(Operator.Add().parse, Operator.Sub().parse)
    val level1: Ref<Chr, Expression> = Parser.ref()

    val level2Ops = choice(Operator.Mul().parse, Operator.Div().parse)
    val level2: Ref<Chr, Expression> = Parser.ref()

    val level3: Ref<Chr, Expression> = Parser.ref()
    val varCheck = product(varname.andL(addWs(chr('='))), level1)

    constructor() {
        var temp = level2.and(
            product(level1Ops, level1).optional()
        )
            .map { a, b -> makeExpr(a, b) }
        level1.set(temp)


        temp = level3.and(
            product(level2Ops, level2).optional()
        )
            .map { a, b -> makeExpr(a, b) }
        level2.set(temp)

        temp =
            ws.many().andR(level1.between(chr('('), addWs(chr(')'))).or(Expression.dbleExpr()))
        level3.set(temp)


    }

    fun makeExpr(a: Expression, b: Optional<Tuple2<Operator, Expression>>): Expression {
        return b.map { n -> Calculation(n.get1(), a, n.get2()) as Expression }.orElse(a)

    }

    fun <A> addWs(p: Parser<Chr, A>): Parser<Chr, A> {
        return ws.many().andR(p).andL(ws.many())

    }

    fun parse(s: String): String {
        val i = Input.of(s)
        val test = level1.or(varCheck.map { a -> a.get2().evaluate().named(a.get1()) })

        return test.parse(i).match({ a -> a.orThrow.evaluate().toString() }, { _ -> s })
    }

    companion object {
        fun <I, A>choice2(opts:List<Parser<I, A>>): Parser<I, A> {
            val temp = IList.ofIterable(opts)
            return Parser.choice(temp.nonEmptyOpt().orElse(IList.of(fail<I, A>())))
        }

        fun stringChoice(opts:List<String>) : Parser<Chr, String> {
            return choice2(opts.map{a -> string(a)})
        }
    }

}

fun test() {
    chr('+')
    chr('*')

    val level1Ops = choice(Operator.Add().parse, Operator.Sub().parse)
    val level1: Ref<Chr, Expression> = Parser.ref()

    val level2Ops = choice(Operator.Mul().parse, Operator.Div().parse)
    val level2: Ref<Chr, Expression> = Parser.ref()

    var temp = level2.and(
        level1Ops.and(level1)
            .map { a, b -> Pair(a, b) }.optional()
    )
        .map { a, b -> if (b.isEmpty) a else Calculation(b.get().first, a, b.get().second) }
    level1.set(temp)


    temp = Expression.dbleExpr().and(
        level2Ops.and(level2)
            .map { a, b -> Pair(a, b) }.optional()
    )
        .map { a, b -> if (b.isEmpty) a else Calculation(b.get().first, a, b.get().second) }
    level2.set(temp)

    val v1 = "-1/2/3/4"
    val v2 = "1-2-3-4-6"
    println("hello world")
    val temp1 = level1.parse(Input.of(v1)).getOrThrow()
    val temp2 = level1.parse(Input.of(v2)).getOrThrow()
    println(temp1.evaluate())
    println(temp1)
    println(temp2.evaluate())
    println(temp2)

}